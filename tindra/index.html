<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Tindra Lost</title>
  <style>
      @media (max-width: 768px) {
      #mobile-controls {
        display: flex !important;
      }

      canvas#game {
        touch-action: none; /* Prevent pinch-zoom etc. */
      }
    }
    body {
      margin: 0;
      overflow: hidden;
      touch-action: none;
    }
    body {
      font-family: sans-serif;
      text-align: center;
      background: #e0f7fa;
    }
    canvas {
      border: 2px solid #333;
      background: #fff;
    }
    #info {
      margin: 10px;
    }
    #mobile-controls {
      position: absolute;
      bottom: 20px;
      left: 20px;
      z-index: 10;
      display: flex;
      align-items: center;
      gap: 20px;
    }

    #joystick-base {
      width: 150px;
      height: 150px;
      border-radius: 50%;
      background: rgba(100, 100, 100, 0.4);
      position: relative;
      touch-action: none;
      mask-image: linear-gradient(to top, transparent 50%, black 50%);
      -webkit-mask-image: linear-gradient(to top, transparent 30%, black 50%);
    }

    #joystick-thumb {
      width: 60px;
      height: 60px;
      background: rgba(50, 50, 200, 0.7);
      border-radius: 50%;
      position: absolute;
      left: 45px;
      top: 45px;
      touch-action: none;
    }

    #map-toggle {
      position: absolute;
      top: 20px;
      right: 20px;
      z-index: 20;
      padding: 12px 20px;
      font-size: 18px;
      border-radius: 12px;
      border: none;
      background-color: #222;
      color: white;
      opacity: 0.9;
    }
  </style>
</head>
<body>
  <h1>Tindra Lost</h1>
  <div id="info">Time: <span id="timer">0.0</span> s | Checkpoints: <span id="score">0</span></div>
  <div id="mobile-controls" style="display: none;">
    <div id="joystick-base">
      <div id="joystick-thumb"></div>
    </div>
    <button id="map-toggle">Map</button>
  </div>
  <canvas id="game" width="400" height="400"></canvas>
<canvas id="minimap" width="400" height="400"
  style="display:none; position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); border:2px solid #333; z-index:15; background:#fff;"></canvas>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const timerDisplay = document.getElementById('timer');
    const scoreDisplay = document.getElementById('score');
	const minimapCanvas = document.getElementById('minimap');
	const minimapCtx = minimapCanvas.getContext('2d');
	let minimapVisible = false;

    let startPosition = { x: Math.random() * 15, y: Math.random() * 15 }; // Declared early to avoid ReferenceError
    let startAngle = Math.random() * 6

    const tileSize = 40;
    const chunkSize = 10; //tiles
    const mapSize = 30; //tiles

    const colorMap = {
      '.': '#ccffcc', //
      'T': '#85FF66', //Dense Vegetation
      '~': '#00FFFF', //Water
      '#': '#FFBA36', //Open
      'X': '#222', //Building
    };

    const impassableTiles = ['~', 'X'];
    const darkTiles = ['X']; // Only buildings block light fully

    const semiDarkTiles = ['T']; // Dense vegetation blocks light 50%

    const speedModifiers = {
      '.': 1.0,
      'T': 0.4,
      '#': 1.5,
    };

    let terrainChunks = new Map();
	let checkpoints = [];
	
    function generateRandomCheckpoints() {
      const count = Math.floor(Math.random() * 3) + 6; // 6 to 8
      checkpoints = [];
      const used = new Set();
      while (checkpoints.length < count) {
        const x = Math.floor((Math.random() - 0.5) * mapSize);
        const y = Math.floor((Math.random() - 0.5) * mapSize);
        const key = `${x},${y}`;
        if (!used.has(key)) {
          // Ensure chunk is generated
          const cx = Math.floor(x / chunkSize);
          const cy = Math.floor(y / chunkSize);
          generateChunk(cx, cy);

          const tile = getTile(x, y);
          if (impassableTiles.includes(tile)) continue; // Avoid invalid tiles

          const minDistance = 6; // in tiles
          let tooClose = false;
          for (const cp of checkpoints) {
            const dx = cp.x - x;
            const dy = cp.y - y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < minDistance) {
              tooClose = true;
              break;
            }
          }
          if (tooClose) continue;

          used.add(key);
          checkpoints.push({ x, y, found: false });
        }
      }
    }

    function generateChunk(cx, cy) {
      const key = `${cx},${cy}`;
      if (terrainChunks.has(key)) return;
      const chunk = [];
      for (let y = 0; y < chunkSize; y++) {
        const row = [];
        for (let x = 0; x < chunkSize; x++) {
          const r = Math.random();
          if (r < 0.05) row.push('~');
          else if (r < 0.1) row.push('X');
          else if (r < 0.25) row.push('T');
          else if (r < 0.3) row.push('#');
          else row.push('.');
        }
        chunk.push(row);
      }
      terrainChunks.set(key, chunk);
    }

    function getTile(x, y) {
      const cx = Math.floor(x / chunkSize);
      const cy = Math.floor(y / chunkSize);
      generateChunk(cx, cy);
      const chunk = terrainChunks.get(`${cx},${cy}`);
      const tx = ((x % chunkSize) + chunkSize) % chunkSize;
      const ty = ((y % chunkSize) + chunkSize) % chunkSize;
      return chunk[ty][tx];
    }

    let player = {
      x: startPosition.x,
      y: startPosition.y,
      angle: startAngle
    };

    const baseSpeed = 3.0;
    const turnSpeed = 0.05;
    let keys = {};
    let score = 0;
    let startTime = null;
    let gameOver = false;
    
    let touchAngle = 0;
    let touchDistance = 0;
    let isTouching = false;

    function drawWorld() {
      ctx.save();
      ctx.translate(canvas.width / 2, canvas.height / 2);
      ctx.rotate(-player.angle);
      ctx.translate(-player.x, -player.y);

      const minX = Math.floor((player.x - canvas.width / 2) / tileSize) - 1;
      const maxX = Math.floor((player.x + canvas.width / 2) / tileSize) + 1;
      const minY = Math.floor((player.y - canvas.height / 2) / tileSize) - 1;
      const maxY = Math.floor((player.y + canvas.height / 2) / tileSize) + 1;

      for (let y = minY; y <= maxY; y++) {
        for (let x = minX; x <= maxX; x++) {
          const tile = getTile(x, y);
          ctx.fillStyle = colorMap[tile] || '#ffffff';
          const centerX = x * tileSize + tileSize / 2;
          const centerY = y * tileSize + tileSize / 2;
          ctx.fillRect(centerX - tileSize * 0.55, centerY - tileSize * 0.55, tileSize * 1.1, tileSize * 1.1);
        }
      }

      checkpoints.forEach(cp => {
        if (!cp.found) {
          ctx.fillStyle = 'red';
          ctx.beginPath();
          ctx.arc(cp.x * tileSize + tileSize / 2, cp.y * tileSize + tileSize / 2, tileSize / 4, 0, Math.PI * 2);
          ctx.fill();
        }
      });

      ctx.restore();

      ctx.fillStyle = 'blue';
      ctx.beginPath();
      ctx.arc(canvas.width / 2, canvas.height / 2, tileSize / 4, 0, Math.PI * 2);
      ctx.fill();

      ctx.strokeStyle = 'black';
      ctx.beginPath();
      ctx.moveTo(canvas.width / 2, canvas.height / 2);
      ctx.lineTo(
        canvas.width / 2 + Math.cos(player.angle) * 20,
        canvas.height / 2 + Math.sin(player.angle) * 20
      );
      ctx.stroke();
    }

    function drawFlashlight() {
      const lightRadius = 200;
      const beamAngle = 2 * Math.PI / 3;
      const px = canvas.width / 2;
      const py = canvas.height / 2;

      const gradient = ctx.createRadialGradient(px, py, 0, px, py, lightRadius);
      gradient.addColorStop(0, 'rgba(0, 0, 0, 0.1)');
      gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');

      const maskCanvas = document.createElement('canvas');
      maskCanvas.width = canvas.width;
      maskCanvas.height = canvas.height;
      const maskCtx = maskCanvas.getContext('2d');

      maskCtx.fillStyle = 'rgba(0, 0, 0, 0.9)';
      maskCtx.fillRect(0, 0, canvas.width, canvas.height);

      maskCtx.globalCompositeOperation = 'destination-out';
      maskCtx.beginPath();
      maskCtx.moveTo(px, py);

      for (let a = -beamAngle / 2; a <= beamAngle / 2; a += 0.03) {
        const screenAngle = -Math.PI / 2 + a;
        const worldAngle = screenAngle + player.angle;
        const dist = castRayWorld(worldAngle, lightRadius);
        const rx = px + Math.cos(screenAngle) * dist;
        const ry = py + Math.sin(screenAngle) * dist;
        maskCtx.lineTo(rx, ry);
      }

      maskCtx.closePath();
      maskCtx.fill();

      maskCtx.globalCompositeOperation = 'hue';
      maskCtx.fillStyle = gradient;
      maskCtx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.drawImage(maskCanvas, 0, 0);
    }

    function castRayWorld(angle, maxDist) {
      const step = 4;
      let accumulatedOpacity = 0;
      for (let d = 0; d < maxDist; d += step) {
        const wx = player.x + Math.cos(angle) * d;
        const wy = player.y + Math.sin(angle) * d;
        const tileX = Math.floor(wx / tileSize);
        const tileY = Math.floor(wy / tileSize);
        const tile = getTile(tileX, tileY);

        if (darkTiles.includes(tile)) return d;
        if (semiDarkTiles.includes(tile)) {
          accumulatedOpacity += 0.5;
          if (accumulatedOpacity >= 1) return d;
        }
      }
      return maxDist;
    }

    function update() {
      if (!startTime) startTime = Date.now();
      const elapsed = (Date.now() - startTime) / 1000;
      timerDisplay.textContent = elapsed.toFixed(1);

      if (keys['ArrowLeft']) player.angle -= turnSpeed;
      if (keys['ArrowRight']) player.angle += turnSpeed;

      // Mobile turning (horizontal axis of touch)
      if (isTouching) {
        // Rotation based on horizontal input only
        const turnStrength =Math.sin(touchAngle); // -1 to 1
        player.angle += turnStrength * 0.05;
      }

      let dx = 0, dy = 0;
      let currentTile = getTile(Math.floor(player.x / tileSize), Math.floor(player.y / tileSize));
      let modifier = speedModifiers[currentTile] || 1.0;
      const actualSpeed = baseSpeed * modifier;

      if (keys['ArrowDown'] || isTouching) {
        const moveStrength = Math.cos(touchAngle); // forward=1, backward=-1
        const moveSpeed = actualSpeed * moveStrength * (touchDistance || 1);
        dx = Math.cos(player.angle - Math.PI / 2) * moveSpeed;
        dy = Math.sin(player.angle - Math.PI / 2) * moveSpeed;
      }
      if (keys['ArrowUp']) {
        dx = Math.cos(player.angle - Math.PI / 2) * actualSpeed;
        dy = Math.sin(player.angle - Math.PI / 2) * actualSpeed;
      }

      const nextX = player.x + dx;
      const nextY = player.y + dy;
      const tileX = Math.floor(nextX / tileSize);
      const tileY = Math.floor(nextY / tileSize);
      const tile = getTile(tileX, tileY);

      if (!impassableTiles.includes(tile)) {
        player.x = nextX;
        player.y = nextY;
      }
	  
		const nextCheckpoint = checkpoints.find(cp => !cp.found);
		if (nextCheckpoint) {
		  const cx = nextCheckpoint.x * tileSize + tileSize / 2;
		  const cy = nextCheckpoint.y * tileSize + tileSize / 2;
		  const dist = Math.hypot(player.x - cx, player.y - cy);
		  if (dist < tileSize / 2) {
			nextCheckpoint.found = true;
			score++;
			scoreDisplay.textContent = score;
		  }
		}

    }

	function drawMinimap() {
		minimapCtx.clearRect(0, 0, minimapCanvas.width, minimapCanvas.height);
		const scale = 8; // 2x size tiles
		const halfW = minimapCanvas.width / 2;
		const halfH = minimapCanvas.height / 2;

		const mapCenterX = startPosition.x / tileSize;
		const mapCenterY = startPosition.y / tileSize;

		for (let dy = -25; dy <= 25; dy++) {
		  for (let dx = -25; dx <= 25; dx++) {
			const tx = Math.floor(mapCenterX + dx);
			const ty = Math.floor(mapCenterY + dy);
			const tile = getTile(tx, ty);
			const color = colorMap[tile] || '#fff';
			minimapCtx.fillStyle = color;
			minimapCtx.fillRect(
			  halfW + dx * scale,
			  halfH + dy * scale,
			  scale,
			  scale
			);
		  }
		}

		checkpoints.forEach((cp, index) => {
          const dx = cp.x - mapCenterX;
          const dy = cp.y - mapCenterY;
          const px = halfW + dx * scale;
          const py = halfH + dy * scale;
          minimapCtx.strokeStyle = 'purple';
          minimapCtx.lineWidth = 2;
          minimapCtx.beginPath();
          minimapCtx.arc(px, py, 10, 0, Math.PI * 2);
          minimapCtx.stroke();
          minimapCtx.fillStyle = 'purple';
          minimapCtx.font = 'bold 12px sans-serif';
          minimapCtx.fillText((index + 1).toString(), px - 4, py + 4);
		});

        // Draw lines between unfound checkpoints in order
        minimapCtx.strokeStyle = 'rgba(128, 0, 128, 0.6)'; // Semi-transparent purple
        minimapCtx.lineWidth = 2;
        minimapCtx.beginPath();
        
        const dx = startPosition.x - mapCenterX;
        const dy = startPosition.y - mapCenterY;
        const px = halfW + dx * scale;
        const py = halfH + dy * scale;
        minimapCtx.moveTo(px, py);
        
        checkpoints.forEach(cp => {
          const cdx = cp.x - mapCenterX;
          const cdy = cp.y - mapCenterY;
          const cpx = halfW + cdx * scale;
          const cpy = halfH + cdy * scale;
          minimapCtx.lineTo(cpx, cpy);
        });
        minimapCtx.stroke();


		// Draw player start position as hollow purple triangle
		minimapCtx.strokeStyle = 'purple';
		minimapCtx.lineWidth = 2;
		minimapCtx.beginPath();
		minimapCtx.moveTo(px, py - 20);
		minimapCtx.lineTo(px - 20, py + 15);
		minimapCtx.lineTo(px + 20, py + 15);
		minimapCtx.closePath();
		minimapCtx.stroke();
	}

    document.addEventListener('keydown', (e) => keys[e.key] = true);
    document.addEventListener('keyup', (e) => keys[e.key] = false);
	document.addEventListener('keydown', (e) => {
	keys[e.key] = true;
	if (e.key === 'm' || e.key === 'M') {
		minimapVisible = !minimapVisible;
		minimapCanvas.style.display = minimapVisible ? 'block' : 'none';
	}
	});
	document.addEventListener('keyup', (e) => keys[e.key] = false);
    
    document.getElementById('map-toggle').addEventListener('click', () => {
      minimapVisible = !minimapVisible;
      minimapCanvas.style.display = minimapVisible ? 'block' : 'none';
    });

    const joystickBase = document.getElementById('joystick-base');
    const joystickThumb = document.getElementById('joystick-thumb');

    let baseRect = null;

    joystickBase.addEventListener('touchstart', (e) => {
      isTouching = true;
      baseRect = joystickBase.getBoundingClientRect();
      handleTouch(e);
    });

    joystickBase.addEventListener('touchmove', (e) => {
      handleTouch(e);
    });

    joystickBase.addEventListener('touchend', () => {
      isTouching = false;
      touchDistance = 0;
      joystickThumb.style.left = '30px';
      joystickThumb.style.top = '30px';
    });
    
    document.body.addEventListener('touchmove', (e) => {
      e.preventDefault();
    }, { passive: false }); //prevent scrolling
    

   function handleTouch(e) {
      const touch = e.touches[0];
      const dx = touch.clientX - (baseRect.left + 75); // joystick center X
      const dy = touch.clientY - (baseRect.top + 75);  // joystick center Y

      const dist = Math.min(Math.hypot(dx, dy), 60); // Max thumb movement
      const angle = Math.atan2(dy, dx);

      touchAngle = angle + Math.PI/2;
      touchDistance = dist / 60; // Normalize to [0, 1]

      joystickThumb.style.left = 75 + Math.cos(angle) * dist - 30 + 'px';
      joystickThumb.style.top = 75 + Math.sin(angle) * dist - 30 + 'px';
    }
    
  function resizeMinimap() {
    minimapCanvas.width = window.innerWidth * 0.9;
    minimapCanvas.height = window.innerHeight * 0.9;
  }
    window.addEventListener('resize', resizeMinimap);

  function gameLoop() {
    if (!gameOver) {
      if (!minimapVisible) update();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawWorld();
      drawFlashlight();
      if (minimapVisible) drawMinimap();
      requestAnimationFrame(gameLoop);
    }
  }

    window.onload = () => {
      generateRandomCheckpoints();
	  resizeMinimap();
      // Enable mobile controls only on mobile screens
      if (window.innerWidth <= 768 || 'ontouchstart' in window) {
        document.getElementById('mobile-controls').style.display = 'flex';
      }
    }

    generateChunk(0, 0);
    drawWorld();
    gameLoop();
  </script>
</body>
</html>