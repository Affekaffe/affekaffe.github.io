
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Tindra Lost</title>
  <style>
  @media (max-width: 768px) {
      canvas#game {
        touch-action: none; /* Prevent pinch-zoom etc. */
        flex:1;
      }
    }
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100%;
      width: 100%;
    }
    
    canvas#game {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      display: block;
      touch-action: none;
      border: none;
    }
	canvas {
	  display: block;
	  margin-left: 0px;
	}
    body {
      font-family: sans-serif;
      text-align: center;
      background: #e0f7fa;
    }
    #info {
      margin: 10px;
    }
/* Hide joystick and map on desktop */
@media (min-width: 769px) {
  #joystick-base,
  #map-toggle {
    display: none !important;
  }
}

@media (max-width: 768px) {
  #joystick-base,
  #map-toggle {
    display: block;
  }

  #joystick-base {
    position: absolute;
    bottom: 20%;
    left: 20px;
    width: 150px;
    height: 150px;
    border-radius: 50%;
    background: rgba(100, 100, 100, 0.4);
    z-index: 10;
    touch-action: none;
    display: block;
  }
  
  #joystick-thumb {
	  width: 40%;
	  height: 40%;
	  background: rgba(50, 50, 200, 0.7);
	  border-radius: 50%;
	  position: absolute;
	  left: 30%;
	  top: 30%;
	  touch-action: none;
	}

  #map-toggle {
    position: absolute;
    bottom: 20%;
    right: 20px;
    z-index: 20;
    padding: 40px 40px;
    font-size: 18px;
    border-radius: 12px;
    border: none;
    background-color: #222;
    color: white;
    opacity: 0.9;
  }
}
    #minimap {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-70%, -40%);
      z-index: 20;
      background: transparent;
      pointer-events: none;      /* Keeps it square */
    }
    
    #start-screen {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 50;
    }
    
    #start-button {
      padding: 16px 32px;
      font-size: 24px;
      background: #2196f3;
      color: white;
      border: none;
      border-radius: 12px;
      cursor: pointer;
    }
    
    @media (min-width: 769px) {
      #map-toggle {
        display: none !important;
      }
    }

  </style>
</head>
<body>
  <h1>Tindra Lost</h1>
  <div id="info">Time: <span id="timer">0.0</span> s | Checkpoints: <span id="score">0</span></div>
<div id="joystick-base">
  <div id="joystick-thumb"></div>
</div>
<button id="map-toggle">Map</button>
  <div id="start-screen">
    <h2>Tindra Lost</h2>
    <button id="start-button">Play</button>
  </div>
<canvas id="game"></canvas>
<canvas id="minimap"></canvas>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const timerDisplay = document.getElementById('timer');
    const scoreDisplay = document.getElementById('score');
	const minimapCanvas = document.getElementById('minimap');
	const minimapCtx = minimapCanvas.getContext('2d');
	let minimapVisible = false;

    let startPosition = { x: 0, y: 0}; // Declared early to avoid ReferenceError
    let startAngle = Math.random() * 6

    const tileSize = 40;
    const chunkSize = 10; //tiles
    const mapSize = 30; //tiles

    const colorMap = {
      '.': '#ccffcc', //
      'T': '#85FF66', //Dense Vegetation
      '~': '#00FFFF', //Water
      '#': '#FFBA36', //Open
      'X': '#222', //Building
    };

    const impassableTiles = ['~', 'X'];
    const darkTiles = ['X']; // Only buildings block light fully

    const semiDarkTiles = ['T']; // Dense vegetation blocks light 50%

    const speedModifiers = {
      '.': 1.0,
      'T': 0.4,
      '#': 1.5,
    };

    let terrainChunks = new Map();
	let checkpoints = [];
	
    function generateRandomCheckpoints() {
      const count = Math.floor(Math.random() * 3) + 6; // 6 to 8
      checkpoints = [];
      const used = new Set();
      while (checkpoints.length < count) {
        const x = Math.floor((Math.random() - 0.5) * mapSize);
        const y = Math.floor((Math.random() - 0.5) * mapSize);
        const key = `${x},${y}`;
        if (!used.has(key)) {
          // Ensure chunk is generated
          const cx = Math.floor(x / chunkSize);
          const cy = Math.floor(y / chunkSize);
          generateChunk(cx, cy);

          const tile = getTile(x, y);
          if (impassableTiles.includes(tile)) continue; // Avoid invalid tiles

          const minDistance = 6; // in tiles
          let tooClose = false;
          for (const cp of checkpoints) {
            const dx = cp.x - x;
            const dy = cp.y - y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < minDistance) {
              tooClose = true;
              break;
            }
          }
          if (tooClose) continue;

          used.add(key);
          checkpoints.push({ x, y, found: false });
        }
      }
    }

    function generateChunk(cx, cy) {
      const key = `${cx},${cy}`;
      if (terrainChunks.has(key)) return;
      const chunk = [];
      for (let y = 0; y < chunkSize; y++) {
        const row = [];
        for (let x = 0; x < chunkSize; x++) {
          const r = Math.random();
          if (r < 0.05) row.push('~');
          else if (r < 0.1) row.push('X');
          else if (r < 0.25) row.push('T');
          else if (r < 0.3) row.push('#');
          else row.push('.');
        }
        chunk.push(row);
      }
      terrainChunks.set(key, chunk);
    }

    function getTile(x, y) {
      const cx = Math.floor(x / chunkSize);
      const cy = Math.floor(y / chunkSize);
      generateChunk(cx, cy);
      const chunk = terrainChunks.get(`${cx},${cy}`);
      const tx = ((x % chunkSize) + chunkSize) % chunkSize;
      const ty = ((y % chunkSize) + chunkSize) % chunkSize;
      return chunk[ty][tx];
    }

    let player = {
      x: startPosition.x,
      y: startPosition.y,
      angle: startAngle
    };

    const baseSpeed = 3.0;
    const turnSpeed = 0.05;
    let keys = {};
    let score = 0;
    let startTime = null;
    let gameOver = false;
    
    let touchAngle = 0;
    let touchDistance = 0;
    let isTouching = false;

    function drawWorld() {
      ctx.save();
      ctx.translate(canvas.width / 2, canvas.height / 2);
      ctx.rotate(-player.angle);
      ctx.translate(-player.x, -player.y);

      const minX = Math.floor((player.x - canvas.width / 2) / tileSize) - 1;
      const maxX = Math.floor((player.x + canvas.width / 2) / tileSize) + 1;
      const minY = Math.floor((player.y - canvas.height / 2) / tileSize) - 1;
      const maxY = Math.floor((player.y + canvas.height / 2) / tileSize) + 1;

      for (let y = minY; y <= maxY; y++) {
        for (let x = minX; x <= maxX; x++) {
          const tile = getTile(x, y);
          ctx.fillStyle = colorMap[tile] || '#ffffff';
          const centerX = x * tileSize + tileSize / 2;
          const centerY = y * tileSize + tileSize / 2;
          ctx.fillRect(centerX - tileSize * 0.55, centerY - tileSize * 0.55, tileSize * 1.1, tileSize * 1.1);
        }
      }

      checkpoints.forEach(cp => {
        if (!cp.found) {
          ctx.fillStyle = 'red';
          ctx.beginPath();
          ctx.arc(cp.x * tileSize + tileSize / 2, cp.y * tileSize + tileSize / 2, tileSize / 4, 0, Math.PI * 2);
          ctx.fill();
        }
      });

      ctx.restore();

      ctx.fillStyle = 'blue';
      ctx.beginPath();
      ctx.arc(canvas.width / 2, canvas.height / 2, tileSize / 4, 0, Math.PI * 2);
      ctx.fill();

      ctx.strokeStyle = 'black';
      ctx.beginPath();
      ctx.moveTo(canvas.width / 2, canvas.height / 2);
      ctx.lineTo(
        canvas.width / 2 + Math.cos(player.angle) * 20,
        canvas.height / 2 + Math.sin(player.angle) * 20
      );
      ctx.stroke();
    }

    function drawFlashlight() {
      const lightRadius = 200;
      const beamAngle = 2 * Math.PI / 3;
      const px = canvas.width / 2;
      const py = canvas.height / 2;

      const gradient = ctx.createRadialGradient(px, py, 0, px, py, lightRadius);
      gradient.addColorStop(0, 'rgba(0, 0, 0, 0.1)');
      gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');

      const maskCanvas = document.createElement('canvas');
      maskCanvas.width = canvas.width;
      maskCanvas.height = canvas.height;
      const maskCtx = maskCanvas.getContext('2d');

      maskCtx.fillStyle = 'rgba(0, 0, 0, 0.9)';
      maskCtx.fillRect(0, 0, canvas.width, canvas.height);

      maskCtx.globalCompositeOperation = 'destination-out';
      maskCtx.beginPath();
      maskCtx.moveTo(px, py);

      for (let a = -beamAngle / 2; a <= beamAngle / 2; a += 0.03) {
        const screenAngle = -Math.PI / 2 + a;
        const worldAngle = screenAngle + player.angle;
        const dist = castRayWorld(worldAngle, lightRadius);
        const rx = px + Math.cos(screenAngle) * dist;
        const ry = py + Math.sin(screenAngle) * dist;
        maskCtx.lineTo(rx, ry);
      }

      maskCtx.closePath();
      maskCtx.fill();

      maskCtx.globalCompositeOperation = 'hue';
      maskCtx.fillStyle = gradient;
      maskCtx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.drawImage(maskCanvas, 0, 0);
    }

    function castRayWorld(angle, maxDist) {
      const step = 4;
      let accumulatedOpacity = 0;
      for (let d = 0; d < maxDist; d += step) {
        const wx = player.x + Math.cos(angle) * d;
        const wy = player.y + Math.sin(angle) * d;
        const tileX = Math.floor(wx / tileSize);
        const tileY = Math.floor(wy / tileSize);
        const tile = getTile(tileX, tileY);

        if (darkTiles.includes(tile)) return d;
        if (semiDarkTiles.includes(tile)) {
          accumulatedOpacity += 0.5;
          if (accumulatedOpacity >= 1) return d;
        }
      }
      return maxDist;
    }

    function update() {
      if (!startTime) startTime = Date.now();
      const elapsed = (Date.now() - startTime) / 1000;
      timerDisplay.textContent = elapsed.toFixed(1);

      if (keys['ArrowLeft']) player.angle -= turnSpeed;
      if (keys['ArrowRight']) player.angle += turnSpeed;

      // Mobile turning (horizontal axis of touch)
      if (isTouching) {
        // Rotation based on horizontal input only
        const turnStrength =Math.sin(touchAngle); // -1 to 1
        player.angle += turnStrength * 0.05;
      }

      let dx = 0, dy = 0;
      let currentTile = getTile(Math.floor(player.x / tileSize), Math.floor(player.y / tileSize));
      let modifier = speedModifiers[currentTile] || 1.0;
      const actualSpeed = baseSpeed * modifier;

      if (keys['ArrowUp'] || isTouching) {
        const moveStrength = Math.cos(touchAngle); // forward=1, backward=-1
        const moveSpeed = actualSpeed * moveStrength * (touchDistance || 1);
        dx = Math.cos(player.angle - Math.PI / 2) * moveSpeed;
        dy = Math.sin(player.angle - Math.PI / 2) * moveSpeed;
      }
      if (keys['ArrowDown']) {
        dx = -Math.cos(player.angle - Math.PI / 2) * actualSpeed;
        dy = -Math.sin(player.angle - Math.PI / 2) * actualSpeed;
      }

      const nextX = player.x + dx;
      const nextY = player.y + dy;
      const tileX = Math.floor(nextX / tileSize);
      const tileY = Math.floor(nextY / tileSize);
      const tile = getTile(tileX, tileY);

      if (!impassableTiles.includes(tile)) {
        player.x = nextX;
        player.y = nextY;
      }
	  
		const nextCheckpoint = checkpoints.find(cp => !cp.found);
		if (nextCheckpoint) {
		  const cx = nextCheckpoint.x * tileSize + tileSize / 2;
		  const cy = nextCheckpoint.y * tileSize + tileSize / 2;
		  const dist = Math.hypot(player.x - cx, player.y - cy);
		  if (dist < tileSize / 2) {
			nextCheckpoint.found = true;
			score++;
			scoreDisplay.textContent = score;
		  }
		}

    }

	function drawMinimap() {
		const scale = 8; // 2x size tiles
		const halfW = minimapCanvas.width / 2;
		const halfH = minimapCanvas.height / 2;

		const mapCenterX = startPosition.x / tileSize;
		const mapCenterY = startPosition.y / tileSize;

		for (let dy = -25; dy <= 25; dy++) {
		  for (let dx = -25; dx <= 25; dx++) {
			const tx = Math.floor(mapCenterX + dx);
			const ty = Math.floor(mapCenterY + dy);
			const tile = getTile(tx, ty);
			const color = colorMap[tile] || '#fff';
			minimapCtx.fillStyle = color;
			minimapCtx.fillRect(
			  halfW + dx * scale,
			  halfH + dy * scale,
			  scale,
			  scale
			);
		  }
		}

		checkpoints.forEach((cp, index) => {
          const dx = cp.x - mapCenterX;
          const dy = cp.y - mapCenterY;
          const px = halfW + dx * scale;
          const py = halfH + dy * scale;
          minimapCtx.strokeStyle = 'purple';
          minimapCtx.lineWidth = 2;
          minimapCtx.beginPath();
          minimapCtx.arc(px, py, 10, 0, Math.PI * 2);
          minimapCtx.stroke();
          minimapCtx.fillStyle = 'purple';
          minimapCtx.font = 'bold 12px sans-serif';
          minimapCtx.fillText((index + 1).toString(), px - 4, py + 4);
		});

        // Draw lines between unfound checkpoints in order
        minimapCtx.strokeStyle = 'rgba(128, 0, 128, 0.6)'; // Semi-transparent purple
        minimapCtx.lineWidth = 2;
        minimapCtx.beginPath();
        
        const dx = startPosition.x - mapCenterX;
        const dy = startPosition.y - mapCenterY;
        const px = halfW + dx * scale;
        const py = halfH + dy * scale;
        minimapCtx.moveTo(px, py);
        
        checkpoints.forEach(cp => {
          const cdx = cp.x - mapCenterX;
          const cdy = cp.y - mapCenterY;
          const cpx = halfW + cdx * scale;
          const cpy = halfH + cdy * scale;
          minimapCtx.lineTo(cpx, cpy);
        });
        minimapCtx.stroke();


		// Draw player start position as hollow purple triangle
		minimapCtx.strokeStyle = 'purple';
		minimapCtx.lineWidth = 2;
		minimapCtx.beginPath();
		minimapCtx.moveTo(px, py - 20);
		minimapCtx.lineTo(px - 20, py + 15);
		minimapCtx.lineTo(px + 20, py + 15);
		minimapCtx.closePath();
		minimapCtx.stroke();
	}

    document.addEventListener('keydown', (e) => keys[e.key] = true);
    document.addEventListener('keyup', (e) => keys[e.key] = false);
	document.addEventListener('keydown', (e) => {
	keys[e.key] = true;
	if (e.key === 'm' || e.key === 'M') {
		minimapVisible = !minimapVisible;
		minimapCanvas.style.display = minimapVisible ? 'block' : 'none';
	}
	});
	document.addEventListener('keyup', (e) => keys[e.key] = false);
    
    document.getElementById('map-toggle').addEventListener('click', () => {
      minimapVisible = !minimapVisible;
      minimapCanvas.style.display = minimapVisible ? 'block' : 'none';
    });

    const joystickBase = document.getElementById('joystick-base');
    const joystickThumb = document.getElementById('joystick-thumb');

    let baseRect = null;

    joystickBase.addEventListener('touchstart', (e) => {
      isTouching = true;
      baseRect = joystickBase.getBoundingClientRect();
      handleTouch(e);
    });

    joystickBase.addEventListener('touchmove', (e) => {
      handleTouch(e);
    });

    joystickBase.addEventListener('touchend', () => {
      isTouching = false;
      touchDistance = 0;
	  joystickThumb.style.left = '30%';
	  joystickThumb.style.top = '30%';
    });
    
    document.body.addEventListener('touchmove', (e) => {
      e.preventDefault();
    }, { passive: false }); //prevent scrolling
    

	function handleTouch(e) {
	  const touch = e.touches[0];
	  const baseCenterX = baseRect.left + baseRect.width / 2;
	  const baseCenterY = baseRect.top + baseRect.height / 2;
	  const dx = touch.clientX - baseCenterX;
	  const dy = touch.clientY - baseCenterY;

	  const maxDist = baseRect.width / 2;
	  const dist = Math.min(Math.hypot(dx, dy), maxDist);
	  const angle = Math.atan2(dy, dx);

	  touchAngle = angle + Math.PI / 2;
	  touchDistance = dist / maxDist;

	  const thumbSize = baseRect.width * 0.4;
	  joystickThumb.style.left = baseRect.width / 2 + Math.cos(angle) * dist - thumbSize / 2 + 'px';
	  joystickThumb.style.top = baseRect.height / 2 + Math.sin(angle) * dist - thumbSize / 2 + 'px';
	}
    
	function resizeMinimap() {
	  minimapCanvas.width = window.innerWidth;
	  minimapCanvas.height = window.innerHeight;
	}
	window.addEventListener('resize', resizeMinimap);

 	function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);

    resizeMinimap();
    resizeCanvas();

    function gameLoop() {
      if (!gameOver) {
        if (!minimapVisible) update();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawWorld();
        drawFlashlight();
        if (minimapVisible) drawMinimap();
        requestAnimationFrame(gameLoop);
      }
    }
   
    document.getElementById('start-button').addEventListener('click', async () => {
      const startScreen = document.getElementById('start-screen');
      startScreen.style.display = 'none';
    
      // Fullscreen only on mobile
      if (window.innerWidth <= 768 && document.documentElement.requestFullscreen) {
        try {
          await document.documentElement.requestFullscreen();
        } catch (err) {
          console.warn("Fullscreen failed:", err);
        }
      }
    
      gameLoop();
    });
    
    window.onload = () => {
      generateRandomCheckpoints();
    }

    generateChunk(0, 0);
    drawWorld();
  </script>
</body>
</html>
